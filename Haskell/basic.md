# Haskell の基礎

## 参考
- 『すごい Haskell たのしく学ぼう！』

## はじめに
- **純粋関数型言語**である Haskell は、**副作用を持たない**関数を基本とする  
  - 一度束縛(代入)した変数の値は変更不可  
  - 同じ引数に対して常に同じ結果を返す「参照透明性」をもつ  
- **遅延評価**(必要になったときに初めて計算)を行うため、無限リストなどを自然に扱える  
- **静的型付け**かつ強力な**型推論**を備え、型エラーはコンパイル時に検出される  

---

## 1章: Haskell の基本

### ghci (対話的環境)
- `ghci` コマンドで対話的に Haskell の式を評価可能  
- ファイルをロードするときは `:l ファイル名` を使う

### 真理値
```haskell
ghci> True && False  -- 論理積
False
ghci> True || False  -- 論理和
True
ghci> not False      -- 否定
True
```
- 型を混在させる演算は基本的にできない (例: `5 + "hoge"` はエラー)  
- 整数 + 浮動小数点数 → 浮動小数点数

### 関数適用と演算子
- 通常の関数適用は最も優先度が高い  
  - `f 3 + 4` は `(f 3) + 4` と解釈される  
- 関数が2引数の場合、バッククォートで囲むと中置演算子のように使える  
  ```haskell
  ghci> div 92 10
  9
  ghci> 92 `div` 10
  9
  ```
- `succ x` で次の値、`min` / `max` などの便利関数あり

### 関数定義
- 関数名に続けて引数を書く
  ```haskell
  double x = x + x
  ```
- 関数内で他の関数を呼ぶことも可能
  ```haskell
  doubleUs x y = double x + double y
  ```
- `if` は式として扱われ、必ず `else` が必要
  ```haskell
  doubleSmallNumber x = if x > 100 then x else x * 2
  ```
- 関数名は基本的に**小文字で始める**

### 定義（名前）について
- 値を取らない定義も可能（いわゆる定数）
  ```haskell
  bar = "Bar"
  ```

---

## リスト
- Haskell のリストは「同じ型の要素の集まり」  
- 要素数の変更や結合を行いやすい
  ```haskell
  ghci> let numbers = [4, 7]
  ghci> numbers
  [4,7]
  ```
- 連結は `++`、先頭への追加は `:`(cons) で表現
  ```haskell
  [1,2,3] ++ [4,5]  -- [1,2,3,4,5]
  'A' : " BC"      -- " ABC"
  ```
- 添え字による要素アクセスは `!!` 演算子
  ```haskell
  ghci> [2,4,6,8] !! 1
  4
  ```

- **リスト中の型**  
  同じ型の要素だけでリストを構成する必要がある。異なる型混在のリストは作れない。

- **リストの比較**  
  - 要素が比較可能な型（Ord型クラスのインスタンス）であれば、リスト同士も辞書順で比較される。  
  - 先頭から順に比較し、要素が等しければ次の要素を比較。  
  - 空リストと比べる場合は、非空リストが常に大きいとみなされる。
  ```haskell
  ghci> [3,4,2] < [3,4,3]  -- 先頭要素が同じなので次を比較
  True
  ghci> [3,4,2] > [2,4]    -- 先頭が3と2で比較される
  True
  ghci> [3,4,2] < [3,4,2]  
  False
  ghci> [3,4,2] > [3,4,2]
  False
  ghci> [1] > []
  True
  ```

- **リストの要素を取り出す基本的な関数**  
  - `head` : リストの先頭の要素  
  - `tail` : リストの先頭を除いた残りの要素  
  - `last` : リストの最後の要素  
  - `init` : リストの最後の要素を除いた前の要素  
  - これらはいずれも**空リスト**に対してはエラーが起こるので注意。

- **リストに対するユーティリティ関数**  
  - `length` : リストの長さを返す  
  - `null` : リストが空かどうか判定する  
  - `reverse` : リストを逆順にした新しいリストを返す  
  - `take n list` : 先頭から `n` 個の要素を取り出す  
    - `n` がリストの長さを超えていてもエラーにはならず、リスト全体が返る  
    - `n` が 0 の場合は空リストを返す  
  - `drop n list` : 先頭から `n` 個の要素を削除した残りを返す  
  - `maximum` / `minimum` : 要素が順序付け可能な場合、最大/最小の要素を返す  
  - `sum` : 数値リストの要素の合計を返す  
  - `product` : 数値リストの要素の積を返す  
  - `elem x list` : `x` が `list` の中に含まれているかを判定する  
    ```haskell
    ghci> 4 `elem` [3,4,5,6]
    True
    ghci> 10 `elem` [3,4,5,6]
    False
    ```

---

## レンジ (範囲指定)

- **`[start..end]` の形で列挙可能な要素を作れる**  
  ```haskell
  ghci> [1..20]
  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
  ghci> ['a'..'z']
  "abcdefghijklmnopqrstuvwxyz"
  ```

- **ステップを指定したレンジ**  
  ```haskell
  ghci> [2,4..20]
  [2,4,6,8,10,12,14,16,18,20]
  ghci> [3,6..20]
  [3,6,9,12,15,18]
  ```
  - 与えられた最初の2要素の差をステップとして扱う  
  - あまり複雑な数列（等差でないなど）を自動で推定することはできない

- **無限リスト**  
  - 上限を指定しない範囲（例: `[1..]`）は無限リストとなる。  
  - Haskell の遅延評価のおかげで、必要な分だけ評価する。  
  - 例：13 の倍数の最初の24個を取りたい場合  
    ```haskell
    ghci> take 24 [13,26..]
    [13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,208,221,234,247,260,273,286,299,312]
    ```
  
- **よく使われる無限リストを生成する関数**  
  - `cycle list` : リスト全体を無限に繰り返す  
  - `repeat x` : 単一の要素 `x` を無限に繰り返すリスト  
  - `replicate n x` : 要素 `x` を `n` 個繰り返した有限リストを返す  

- **浮動小数点数のレンジ**  
  - 浮動小数点の精度の影響で期待と異なる結果になることがある  
  ```haskell
  ghci> [0.1,0.3..1]
  [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
  ```

---

## リスト内包表記

- **リストに対するフィルタリング・変換を数学的な「内包表記」のように表す**  
  ```haskell
  [式 | 変数 <- リスト, 条件式1, 条件式2, ...]
  ```
- たとえば「1 から 10 までの数を 2 倍にした要素のリストを作る」なら  
  ```haskell
  [x * 2 | x <- [1..10]]
  -- 結果: [2,4,6,8,10,12,14,16,18,20]
  ```
- 内包表記にはフィルタ（`| x <- [1..10], x*2 >= 8` など）も追加できる。
